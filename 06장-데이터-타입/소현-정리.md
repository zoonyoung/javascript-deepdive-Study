# $\sf{\color{#FD9A2E}6장)\ 데이터타입}$
---
### $\sf{\color{#FACD2F}0)}$
#### 🔶 데이터 타입
```
값의 종류(7개)
```
| 구분 | 데이터타입 | 설명 |
|:----------|:----------|:----------|
| **원시 타입** | number | 정수, 실수 구분X |
| (변경 불가능) | string | 문자열 |
|  | boolean | true, false |
|  | undefined | 변수 선언 → 암묵적 할당 값 |
|  | null | '값이 없다'의 의도적 명시 |
|  | symbol | ES6 에서 추가됨 (new!) |
| **객체 타입** |   | 객체, 함수, 배열 등 |

cf) ES11(2020ver) 기준 데이터 타입은 8개<br>
(BigInt: 2^53 -1 보다 큰 정수 표현 가능한 원시 값이 추가됨)

---
### $\sf{\color{#FACD2F}1)\ 숫자\ 타입}$ number
#### 🔶 숫자 타입
```
: 배정일도 64bit(8byte) 부동소수점 형식 (double과 비슷)

- 다른 언어와 달리 정수/실수 구분 X

- 2 진수, 8 진수, 16 진수 데이터 타입 X
  0b010000001 = 0o101 = 0x41 ⇒ 65

- 숫자 타입은 실수로 처리되기 때문 정수/정수 = 실수 나올 수 있을
```
- Infinity : 양의 무한대
- -Infinity : 음의 무한대
- NaN :  산술 연산 불가 (not-a-namber)
  
```javascript
console.log(10/0);           //Infinity
console.log(10/-0);          //-Infinity
console.log(1*'string');     //NaN
```

---
### $\sf{\color{#FACD2F}2)\ 문자열\ 타입}$ string
#### 🔶 문자열 타입
```
: 0개 이상의 16bit(2byte) 유니코드 문자 (UTF-16)의 집합

❗️ 다른 언어와 달리 문자열 생성 후 변경 불가능
```
```javascript
var string;
string = ' "큰 따옴표 ", \'작은 따음표\' '     //주로 사용
string = " \"큰 따옴표\", '작은 따옴표' "
string = ` "큰 따옴표", '작은 따음표' `         //(ES6)
```

---
### $\sf{\color{#FACD2F}3)\ 템플릿\ 리터럴}$
#### 🔶 템플릿 리터럴
```
: (ES6) 문자열 표기법, 백틱 (``)사용

- 멀티라인 문자열, 표현식 삽입, 태그드 템플릿(함수 파라미터를 (항수)`Hello ${name}!`형식으로 삽입 가능!) 등
```

1. 멀티라인 문자열

  | 이스케이프 시퀀스 | 의미 |
  |:----------|:----------|
  | \0 | Null |
  | \b | 백스페이스 |
  | \f | 폼피드 (다음 페이지 시작으로 이동) |
  | \n | 개행(LF) (다음 행으로 이동) |
  | \r | 개행(CR) (커서를 처음으로 이동) |
  | \t | 탭(수평) |
  | \v | 탭(수직) |
  | \uXXXX | 유니코드 (ex)'\uD55C'= '한') |
  | \' | 작은 따옴표(') |
  | \" | 큰 따옴표(") |
  | \\ | 백슬러시(\) |
```
- 일반 문자열과 달리 이스케이프 시퀀스 없이 줄바꿈 공백 등 그대로 적용 가능
```

2. 표현식 삽입
```javascript
var two = 2;
console.log(`Test:${two+3}`);           //Test:5
```

---
### $\sf{\color{#FACD2F}4)\ 불리언\ 타입}$ boolean
#### 🔶 불리언 타입
```
: 논리적 참(true), 거짓(false)
```

---
### $\sf{\color{#FACD2F}5)\ undefined\ 타입}$ undefined
#### 🔶 undefined 타입

- 🟢 변수를 참조했을 때, undefined가 반환된다면?
  - ⇒ 참조한 변수가 선언 이후 값이 할당된 적 없구나!
- 🟢 변수에 의도적으로 undefined를 할당한다면?
  - ⇒ 혼란을 줄 수 있으므로 권장X
- 🟢 변수에 값이 없다는 것을 명시하고 싶다면?
  - ⇒ undefined 할당 (X), null 할당 (O)

---
### $\sf{\color{#FACD2F}6)\ null\ 타입}$ null
#### 🔶 null 타입
```
: 변수에 값이 없다는 것을 의도적으로 명시

- 함수가 유효한 값을 반환할 수 없는 경우 명시적으로 null을 반환하기도 한다.
```
- 🟢 변수에 null을 할당한다면?
  - ⇒ 이전에 할당된 값에 대한 참조를 명시적 제거

---
### $\sf{\color{#FACD2F}7)\ 심벌\ 타입}$ symbol (→ 33장)
#### 🔶 심벌 타입
```
: 다른 값과 중복되지 않는 유일무이 한 값
  ⇒ 주로 이름이 충돌할 위험이 없는 객체의 유일한 프로퍼티 키를 만들기 위해 사용

- symbol 항수를 호출해 생성
  ⇒ 생성된 심벌 값은 외부에 노출X, 다른 값과 절대 중복X인 유일무이한 값
```

---
### $\sf{\color{#FACD2F}8)\ 객체\ 타입}$ (→ 11장)
#### 🔶 객체 타입
```
- JS는 객체 기반 언어
```

---
### $\sf{\color{#FACD2F}9)\ 데이터\ 타입의\ 필요성}$

1. 메모리 공간의 확보와 참조
   
- 메모리에 값을 저장할 때, 몇 byte의 공간을 사용해야 낭비와 손실 없이 저장할 수 있을까?
- 🟢 저장할 변수의 데이터 타입이 숫자라면?
  - ⇒ 8byte 확보하여 변수를 2진수로 저장
- 🟢 참조할 변수의 데이터 타입이 숫자라면?
  - ⇒ 8byte 단위로 공간에 저장된 값을 읽는다.

2. 값의 해석
- 메모리에서 읽어들인 2진수를 데이더 타입에 맞게 해석

3. 정리
- 값을 저장할 때 확보할 메모리 공간 크기 결정 가능
- 값을 창조할 때 읽어들일 메모리 공간 크기 결정 가능
- 메모리에서 읽어들인 그진수의 해석 방법 결정 가능

---
### $\sf{\color{#FACD2F}10)\ 동적\ 타이핑}$
#### 🔶 정적 타입 언어
```
: 변수를 선언할 때, 데이터 타입 사전 선언 필수
⇒ 명시적 선언

- 변수 타입 변경 X
- 변수에 선언한 타입에 맞는 값만 할당 가능
- 컴파일 시점에 타입 체크를 통해 일관성 강제

- 🔵 안정적인 코드 구현 ⇒ 런타임에 발생하는 에러↓

ex) C, JAVA, Kotlin…
```

#### 🔶 동적 타입 언어
```
: 변수 선언이 아닌 할당에 의해 타입 결정
  ⇒ 타입 추론

- 변수 타입 언제든지 동적으로 변경 (by 재할당)

🔵 모든 데이터타입을 자유롭게 할당가능 → 편리
🔴 복잡한 프로그램에서 변화하는 변수 값 추적 어려움,
   값을 확인하기 전에 타입 확신할 수 X,
   JS 엔진이 암욱적으로 타입을 자동 변환할 수 있음
⇒ 🔵 유연성↑, 🔴 신뢰성↓

ex) Javascript, Python…
```

#### 🔶 변수 사용시 주의점
1. 변수는 꼭 필요한 경우에 제한적 사용<br>
  변수 개수↑ ⇒ Js가 타입을 잘못 예측한 오류 발생확률↑

2. 변수의 유효범위(스코프)는 최대한 좁게!<br>
변수의 스코프↑ ⇒ 변수로 인한 오류 발생↑

4. 전역 변수는 최대한 사용 X<br>
전역변수 ⇒ 의도치 않게 값이 변경될 가능성↑, 다른 코드에 영향을 줄 가능성↑

4. 변수보다는 상수 사용 (값의 변경 억제)
   
5. 변수 이름을 목적, 의미 파악에 쉽게 네이밍<br>
협업, 생산성 향상에 도움
```
좋은 코드는 "가독성 좋은 코드!"
```
